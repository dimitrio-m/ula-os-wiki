---
title: Estructura del kernel
description: Arquitecturas de sistemas operativos (monolítico vs. microkernel) y el proceso de arranque (Boot).
navigation:
  title: 'Arquitectura del kernel'
  icon: 'i-heroicons-building-library'
---

# Estructura del kernel

::u-alert
---
title: El debate Tanenbaum-Torvalds
description: En 1992, Andrew Tanenbaum (creador de Minix) y Linus Torvalds (creador de Linux) tuvieron una discusión legendaria. Tanenbaum decía que los kernels monolíticos eran obsoletos. Linus decía que el rendimiento importaba más que la elegancia teórica. Linux ganó en el mercado, pero la teoría sigue siendo válida.
icon: i-heroicons-chat-bubble-left-right
color: orange
variant: soft
---
::

Un sistema operativo moderno como Linux tiene más de 30 millones de líneas de código. ¿Cómo organizas semejante monstruo? No puedes ponerlo todo en un solo `main.c`.

Existen dos filosofías principales de diseño para estructurar el código que corre en modo privilegiado.

---

## 1. Kernel monolítico

Es la arquitectura tradicional de UNIX y Linux.
* **Filosofía:** "Todo o nada". El kernel es un solo programa binario gigante que contiene la gestión de procesos, memoria, sistemas de archivos y drivers de dispositivos.
* **Ubicación:** Todo corre en **Ring 0** (Kernel Mode).
* **Comunicación:** Las funciones se llaman directamente entre sí (rápido).

::u-page-grid
---
class: 'lg:grid-cols-2 mt-4'
---
  ::u-page-card
  ---
  icon: i-heroicons-rocket-launch
  title: 'Ventajas'
  variant: subtle
  ---
  **Rendimiento extremo.** No hay *overhead* de mensajes. Si el driver de red quiere hablar con la memoria, simplemente llama a una función.
  ::

  ::u-page-card
  ---
  icon: i-heroicons-exclamation-triangle
  title: 'Desventajas'
  variant: subtle
  ---
  **Fragilidad.** Si un driver de impresora tiene un *bug* y escribe en una dirección de memoria incorrecta, puede corromper todo el kernel y causar un *Kernel Panic*. Todo el sistema cae por culpa de un driver.
  ::
::



---

## 2. Microkernel

Es la arquitectura académica por excelencia (Minix, GNU Hurd, Mach).
* **Filosofía:** "Menos es más". El kernel solo debe tener lo mínimo indispensable para que el sistema arranque (planificador, gestión básica de memoria y comunicación).
* **Ubicación:** Los sistemas de archivos, drivers y protocolos de red corren en **Ring 3** (User Space) como si fueran procesos normales.
* **Comunicación:** A través de paso de mensajes (*Message Passing*).

::u-page-grid
---
class: 'lg:grid-cols-2 mt-4'
---
  ::u-page-card
  ---
  icon: i-heroicons-shield-check
  title: 'Ventajas'
  variant: subtle
  ---
  **Estabilidad.** Si el driver de audio falla, el kernel simplemente lo reinicia. El sistema no se cuelga. Es ideal para sistemas de misión crítica.
  ::

  ::u-page-card
  ---
  icon: i-heroicons-clock
  title: 'Desventajas'
  variant: subtle
  ---
  **Rendimiento.** Para que el sistema de archivos lea del disco, tiene que enviar mensajes al kernel, que los reenvía al driver... Demasiados cambios de contexto.
  ::
::



---

## La realidad: Módulos cargables (LKMs)

Linux es monolítico, pero aprendió un truco.
Para no tener que recompilar todo el kernel cada vez que inventan un nuevo dispositivo USB, Linux usa **Loadable Kernel Modules (LKM)**.

* El núcleo (`vmlinuz`) es pequeño.
* Los drivers (video, wifi, fs) son archivos separados (`.ko`) que se cargan y descargan dinámicamente en tiempo de ejecución (`insmod`, `modprobe`), pero una vez cargados, corren en **Ring 0** con acceso total.

> **Resumen:** Linux es un kernel monolítico con diseño modular.

---

## Bonus: El proceso de arranque (Boot Process)

¿Qué pasa desde que presionas el botón de encendido hasta que ves el login?

::u-steps
  ### 1. BIOS / UEFI
  Al recibir energía, la placa base ejecuta un pequeño software en ROM. Verifica el hardware (POST) y busca un dispositivo de arranque (Disco, USB).

  ### 2. Bootloader (GRUB)
  El BIOS carga el primer sector del disco (MBR o partición EFI) en RAM y lo ejecuta. El Bootloader es un programa simple que sabe leer el sistema de archivos para encontrar el kernel.

  ### 3. Carga del kernel
  GRUB carga el archivo del kernel (`/boot/vmlinuz`) en memoria y le transfiere el control de la CPU. Aquí se inicializan las estructuras de datos (tablas de páginas, interrupciones).

  ### 4. El proceso Init (PID 1)
  Una vez que el kernel está listo, crea el primer proceso de usuario: `systemd` o `init`. Este es el padre de todos los procesos.

  ### 5. User Space
  `systemd` carga el resto de servicios (red, interfaz gráfica, login) basándose en archivos de configuración.
::
