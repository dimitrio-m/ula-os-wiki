---
title: Historia y evolución
description: De los sistemas por lotes al tiempo compartido y la nube. Cómo la economía del hardware dictó la arquitectura del software.
navigation:
  title: 'Evolución histórica'
  icon: 'i-heroicons-clock'
---

# Evolución de los sistemas operativos

::u-alert
---
title: La historia es circular
description: Lo que empezó con mainframes gigantes (computación centralizada) evolucionó a PCs (descentralizada) y ahora ha vuelto a la nube (centralizada). Entender el pasado es entender AWS y Kubernetes hoy.
icon: i-heroicons-arrow-path
color: warning
variant: soft
---
::

La evolución de los sistemas operativos no es una línea recta de "progreso", sino una respuesta directa a una pregunta económica: **¿Qué es más caro, el tiempo de la máquina o el tiempo del humano?**

A continuación, recorremos las cuatro eras que definieron la arquitectura actual, basándonos en la clasificación clásica de Silberschatz.

---

## Era 1: Procesamiento por lotes (*Batch Processing*)
**Contexto:** Años 50-60.
* **El problema:** Las computadoras costaban millones de dólares. El tiempo de CPU era oro. Si un operador humano tardaba 10 segundos en cambiar una cinta magnética, eran 10 segundos de dinero perdido.
* **La solución:** Eliminar al humano del bucle de ejecución.

Los trabajos se agrupaban en "lotes" (batches). Un pequeño programa residente en memoria, el **Monitor Residente** (el tatarabuelo del Kernel), cargaba un programa tras otro automáticamente.

::u-page-grid
---
class: 'lg:grid-cols-2'
---
  ::u-page-card
  ---
  icon: i-heroicons-archive-box
  title: 'Característica clave'
  variant: subtle
  ---
  El usuario no interactúa con la máquina. Entregas tu código (tarjetas) y vuelves mañana por el resultado.
  ::

  ::u-page-card
  ---
  icon: i-heroicons-server
  title: 'Legado moderno'
  variant: subtle
  ---
  Aunque ya no usamos tarjetas, el concepto vive en **CI/CD Pipelines** y sistemas de colas como **RabbitMQ** o **Slurm** en supercomputadoras.
  ::
::



[Image of batch processing system diagram]


---

## Era 2: Multiprogramación (*Spooling*)
**Contexto:** Años 60.
* **El problema:** La CPU es electrónica (nanosegundos), pero los dispositivos de E/S son mecánicos (milisegundos). La CPU pasaba el 90% del tiempo "esperando" a que la cinta o el disco terminaran de leer.
* **La solución:** No dejar que la CPU descanse.

Si el **Trabajo A** necesita esperar por una lectura de disco, el SO cambia inmediatamente el contexto y ejecuta el **Trabajo B**.

> **Nacimiento de la gestión de memoria:** Para que esto funcione, el SO debe mantener varios programas en RAM al mismo tiempo. Aquí nacen los problemas de protección de memoria (que el Trabajo A no borre al Trabajo B).

---

## Era 3: Tiempo compartido (*Time-Sharing*)
**Contexto:** Años 70 (El nacimiento de UNIX).
* **El problema:** Los desarrolladores necesitaban depurar código en tiempo real. El procesamiento por lotes era demasiado lento para el ciclo de desarrollo.
* **La solución:** Multitarea real.

El sistema cambia entre tareas tan rápido (cada pocos milisegundos) que da la **ilusión** de que cada usuario tiene la máquina completa para sí mismo.

::u-steps
  ### 1. Interactividad
  Aparece la terminal (teclado + pantalla). El usuario habla con el SO en tiempo real.

  ### 2. File Systems
  Nace la necesidad de guardar archivos organizados por usuario y carpetas.

  ### 3. Planificación (Scheduling)
  El OS debe decidir matemáticamente a quién darle el siguiente "quantum" de tiempo de CPU.
::

---

## Era 4: Computación personal y distribuida
**Contexto:** Años 80-90 hasta hoy.
* **El problema:** El hardware se volvió barato (Ley de Moore). Ahora lo caro es el tiempo del usuario.
* **La solución:** Optimizar para la conveniencia, no solo para la eficiencia.

Surgieron sistemas como MS-DOS y el Mac OS clásico. Curiosamente, estos sistemas iniciales **retrocedieron** en tecnología: no tenían protección de memoria ni multitarea real (hasta Windows NT y OS X), porque el hardware de PC era muy básico.

### La era moderna (Móvil y Cloud)
Hoy en día, vivimos en una fusión de conceptos:
* **Móvil (Android/iOS):** Son sistemas Unix (Linux/Darwin) altamente optimizados para ahorrar energía, no solo CPU.
* **Cloud & Virtualización:** Un servidor físico corre un **Hipervisor** (un SO para SOs), que corre múltiples máquinas virtuales. Es la multiprogramación llevada al extremo.

---

## Resumen de la evolución

| Era | Objetivo Principal | Innovación Técnica |
| :--- | :--- | :--- |
| **Batch** | Maximizar uso de CPU | Monitor Residente |
| **Multiprogramación** | Evitar espera de I/O | Cambio de contexto |
| **Time-Sharing** | Interactividad humana | Planificación (Scheduling) |
| **PC/Moderno** | Experiencia de usuario | GUI, Redes, Virtualización |


::u-alert
---
title: Reflexión para los proyectos
description: "Cuando construyas tu orquestador ULA-Cloud (Proyecto II), estarás implementando directamente los conceptos de la Era 3: multiprogramación, control de recursos y planificación de CPU para garantizar calidad de servicio."
icon: i-heroicons-light-bulb
color: secondary
variant: outline
---
::
