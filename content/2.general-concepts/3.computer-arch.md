---
title: Arquitectura del computador
description: Repaso de lo visto en la materia de arquitectura de computadoras. Ciclo de instrucción, jerarquía de memoria y mecanismos de E/S (DMA vs Interrupciones).
navigation:
  title: 'Arquitectura base'
  icon: 'i-heroicons-cpu-chip'
---

# Arquitectura del computador

::u-alert
---
title: El hardware dicta el software
description: No puedes escribir un "malloc" eficiente (Proyecto I) ni un servidor web de alto rendimiento (Proyecto Final) si no entiendes cómo viajan los datos entre la CPU y la RAM.
icon: i-heroicons-exclamation-triangle
color: primary
variant: soft
---
::

Todo sistema de computación moderno de propósito general se basa en la **arquitectura de von Neumann**. Su característica definitoria es que no hay distinción física entre **instrucciones** (código) y **datos** (variables). Ambos residen en la misma memoria direccionable.



---

## 1. La CPU y el ciclo de instrucción

La CPU es un motor ciego que repite obsesivamente tres pasos, miles de millones de veces por segundo. Entender este ciclo es vital para comprender cómo el Sistema Operativo "engaña" a la CPU para hacer multitarea.

### El ciclo Fetch-Decode-Execute

1.  **Fetch (Buscar):** La CPU usa el registro **PC (Program Counter)** para pedir a la RAM la siguiente instrucción.
2.  **Decode (Decodificar):** La Unidad de Control interpreta los bits. ¿Es una suma (`ADD`)? ¿Un salto (`JMP`)? ¿Una carga de memoria (`LOAD`)?
3.  **Execute (Ejecutar):** La información pasa a la **ALU (Unidad Aritmético Lógica)**, se realiza la operación y se actualizan los registros o la RAM.

::u-alert
---
title: El cuello de botella de von Neumann
description: La CPU es mucho más rápida procesando datos que la memoria entregándolos. Este fenómeno, conocido como "Von Neumann Bottleneck", obliga a los ingenieros a usar Cachés y predicción de ramas para no desperdiciar ciclos de CPU.
icon: i-heroicons-funnel
color: warning
variant: outline
---
::

---

## 2. La jerarquía de memoria (Latencia y costo)

Como ingenieros, siempre queremos memoria que sea: **Rápida**, **Grande** y **Barata**. La física nos prohíbe tener las tres. La solución es una estructura piramidal.



| Nivel | Tecnología | Tamaño típico | Latencia aprox. | Analogía humana |
| :--- | :--- | :--- | :--- | :--- |
| **Registros** | Flip-flops en CPU | < 1 KB | ~0.3 ns | Lo que tienes en tu mente ahora mismo. |
| **Caché L1** | SRAM | 64 KB | ~1 ns | Un papel en tu escritorio. |
| **Caché L2/L3** | SRAM | 4 MB - 32 MB | ~10 ns | Un libro en la estantería de tu oficina. |
| **RAM (Principal)** | DRAM | 8 GB - 64 GB | ~100 ns | Ir a la biblioteca del campus. |
| **Disco (SSD/HDD)** | Flash / Magnético | TBs | ~100,000 ns - 10 ms | Pedir un libro a otro país por barco. |

> **Lección para el Proyecto 1 (Malloc):**
> Tu asignador de memoria debe intentar mantener los datos juntos (localidad espacial). Si tus datos están dispersos, la CPU pasará más tiempo esperando a la RAM (Cache Misses) que trabajando.

---

## 3. Mecanismos de E/S: Cómo habla el hardware

Aquí es donde el Sistema Operativo brilla. La CPU es el cerebro, pero los periféricos (Disco, Tarjeta de Red, Teclado) son lentos y tontos. Existen tres formas de coordinarlos:

### A. Espera activa (Polling)
La CPU pregunta constantemente al dispositivo: *"¿Ya terminaste? ¿Ya terminaste? ¿Ya terminaste?"*.
* **Ventaja:** Simple de programar.
* **Desventaja:** Desperdicia el 100% de la CPU en espera inútil. Inviable en sistemas modernos.

### B. E/S por interrupciones (Interrupt-Driven)
La CPU le dice al disco: *"Lee este archivo y avísame cuando termines"*. La CPU se va a hacer otra cosa (ej. correr otro proceso). Cuando el disco termina, envía una señal eléctrica (**Interrupción**) que obliga a la CPU a pausar y atender los datos.



### C. DMA (Direct Memory Access) - ¡Nivel Dios!
Para mover grandes volúmenes de datos (ej. un video 4K desde el disco a la RAM), usar interrupciones byte por byte es muy lento.
Aquí entra el **DMA Controller**. La CPU le dice al DMA: *"Mueve 1GB del disco a la dirección 0x5000 de la RAM"*. La CPU se despreocupa totalmente. El chip DMA hace el trabajo pesado y solo interrumpe a la CPU una vez al final.



::u-alert
---
title: Impacto en tu Web Server (Proyecto Final)
description: Los servidores de alto rendimiento (como Nginx o el que harás tú) usan técnicas como sendfile() que aprovechan el DMA para copiar datos del disco a la tarjeta de red sin que la CPU toque los datos. Esto se llama Zero-Copy.
icon: i-heroicons-bolt
color: primary
variant: soft
---
::

---

## Registros clave para el SO

Para gestionar todo esto, el kernel depende de registros de hardware específicos en la CPU:

1.  **PC (Program Counter):** Dirección de la siguiente instrucción.
2.  **SP (Stack Pointer):** Tope de la pila (vital para llamadas a funciones).
3.  **PSW (Program Status Word):** Contiene bits de estado, incluyendo el más importante de todos: el **Bit de Modo (Kernel/User)**.

