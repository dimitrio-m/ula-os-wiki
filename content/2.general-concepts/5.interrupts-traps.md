---
title: Interrupciones y Traps
description: La diferencia entre eventos de hardware (asíncronos) y eventos de software (síncronos). El rol del Timer y el Vector de Interrupciones.
navigation:
  title: 'Interrupciones (Events)'
  icon: 'i-heroicons-bolt'
---

# Interrupciones y excepciones (Traps)

::u-alert
---
title: El OS no siempre está corriendo
description: Es un error común pensar que el Sistema Operativo está ejecutando código constantemente. La mayor parte del tiempo, el OS está "dormido", esperando a que algo ocurra. Lo que lo despierta son las Interrupciones.
icon: i-heroicons-moon
color: secondary
variant: soft
---
::

En la arquitectura moderna, la CPU no "busca" trabajo activamente (*Polling*). En su lugar, el hardware o el software le "gritan" cuando necesitan atención. Dependiendo de quién grite, clasificamos el evento de dos formas:

---

## 1. La Interrupción (Hardware / Asíncrona)

Es una señal eléctrica enviada por un dispositivo externo (Disco, Teclado, Tarjeta de Red) directamente a la CPU.
* **Es Asíncrona:** Puede ocurrir en cualquier momento, sin importar qué instrucción esté ejecutando la CPU ahora mismo.
* **Ejemplo:** Estás escribiendo en Word. Al presionar la tecla "A", el teclado envía una interrupción. La CPU pausa Word, el Kernel lee la tecla, se la pasa a Word y reanuda la ejecución. Todo en microsegundos.

## 2. El Trap o Excepción (Software / Síncrona)

Es un evento generado internamente por la CPU al intentar ejecutar una instrucción específica.
* **Es Síncrona:** Ocurre exactamente en la misma línea de código cada vez que ejecutas el programa.
* **Tipos de Traps:**
    * **Errores (Faults):** División por cero, acceso a memoria inválida (*Segmentation Fault*), instrucción ilegal. El OS suele matar al proceso.
    * **System Calls:** El programa pide un servicio voluntariamente (ej. `int 0x80` en Linux antiguo o `syscall` en x64). El OS atiende la petición y retorna.

---

## El mecanismo: Interrupt Vector Table (IVT)

Cuando ocurre una interrupción (digamos, ID 14 para el Disco Duro), ¿cómo sabe la CPU qué código ejecutar?

La CPU usa una estructura en memoria llamada **Vector de Interrupciones**. Es básicamente un *array* de punteros a funciones.

| ID Interrupción | Dirección de Memoria (Handler) | Descripción |
| :---: | :--- | :--- |
| 0 | `0xF000AE` | División por cero |
| 14 | `0xF000B2` | Controlador de Disco Duro |
| 128 (0x80) | `0xC00000` | System Call (Linux) |

**El flujo de ejecución:**
1.  El dispositivo activa la línea de interrupción.
2.  La CPU termina la instrucción actual.
3.  La CPU guarda el estado actual (Registros y *Program Counter*) en el Stack del Kernel.
4.  La CPU usa el ID para buscar en la tabla y salta a la dirección del **ISR (Interrupt Service Routine)**.
5.  El Kernel ejecuta el ISR.
6.  Al terminar, ejecuta `IRET` (Return from Interrupt) para restaurar el estado y volver al programa de usuario.

---

## El héroe silencioso: El Timer Interrupt

Imagina el siguiente código malicioso (o estúpido):

```c
int main() {
    while(1); // Bucle infinito
}
```

Si el sistema operativo le da la CPU a este proceso, y el proceso nunca llama al OS ni hace I/O... **¿Cómo recupera el OS el control de la computadora?**

Recuerda: El SO es solo un programa. Si la CPU está ocupada ejecutando el `while(1)` del usuario, **no está ejecutando el código del SO**. Si no existiera un mecanismo externo, la única forma de detener este proceso sería apagando la máquina físicamente.

Aquí entra el **Timer (Temporizador programable)**.

Es un chip de hardware en la placa base (como el PIT o APIC) configurado para enviar una **interrupción física** a la CPU cada X milisegundos (ej. cada 10ms o 1ms).

::u-page-grid
---
class: 'lg:grid-cols-2'
---
  ::u-page-card
  ---
  icon: i-heroicons-clock
  title: 'El despertador del kernel'
  variant: subtle
  ---
  Independientemente de lo que esté haciendo el usuario, cuando el Timer dispara, el hardware **fuerza** a la CPU a saltar al manejador de interrupciones del kernel. Es inevitable.
  ::

  ::u-page-card
  ---
  icon: i-heroicons-arrow-path-rounded-square
  title: 'Multitarea preemptiva'
  variant: subtle
  ---
  Gracias al Timer, el OS puede garantizar que **nadie** tenga la CPU para siempre. El planificador (*Scheduler*) despierta, decide si el proceso actual ya consumió su tiempo asignado (*Quantum*), y si es así, realiza un **Context Switch** forzoso.
  ::
::



::u-alert
---
title: Nota para el Proyecto 2 (QoS)
description: Cuando tengas que limitar el uso de CPU de un proceso, no estarás midiendo tiempo real continuo. Estarás contando cuántas interrupciones de Timer ha "sobrevivido" el proceso en ejecución. Si sobrevive demasiadas, tu orquestador deberá pausarlo (`SIGSTOP`) para dar paso a otros.
icon: i-heroicons-chart-bar
color: primary
variant: soft
class: 'mt-6'
---
::

---

## Diferencias clave entre Interrupciones y Traps

Es vital distinguir entre los eventos que vienen de fuera (Hardware) y los que vienen de dentro (Software).

| Característica | Interrupción (Interrupt) | Excepción (Trap) |
| :--- | :--- | :--- |
| **Origen** | Externo (Disco, Timer, Red) | Interno (Tu código) |
| **Sincronía** | **Asíncrona:** Ocurre en cualquier momento impredecible. | **Síncrona:** Ocurre siempre en la misma línea de código. |
| **Propósito** | Notificar eventos de E/S o recuperar control (Timer). | Manejar errores (división por cero) o pedir servicios (System Calls). |
| **Ejemplo** | Paquete de red recibido. | `syscall(SYS_write, ...)` o `int a = 1/0;` |


